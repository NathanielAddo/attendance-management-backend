import { Request, Response } from "express";
import { dataSource } from "../db";
import { parseString } from "fast-csv";

// Extend Request interface for endpoints that rely on req.file (e.g., Multer)
interface MulterRequest extends Request {
  file?: {
    fieldname: string;
    originalname: string;
    encoding: string;
    mimetype: string;
    buffer: Buffer;
    size: number;
  };
}

// Helper to get a schedule by ID (treating scheduleId as a string UUID)
const getScheduleById = async (scheduleId: string) => {
  const scheduleResult = await dataSource.query(
    `SELECT * FROM attendance_schedules WHERE id = $1`,
    [scheduleId]
  );
  if (scheduleResult.length === 0) {
    throw new Error("Schedule not found");
  }
  return scheduleResult[0];
};

// Helper function to validate latitude and longitude
const isValidLocation = (location: { latitude: number; longitude: number }): boolean => {
  return !isNaN(location.latitude) && !isNaN(location.longitude);
};

// Helper to get today’s date string in YYYY-MM-DD format
const getTodayDateString = (): string => {
  const today = new Date();
  return today.toISOString().split("T")[0];
};

// Helper function to validate clock-in time
// Helper function to validate clock-in time with a 10-minute grace period.
const validateClockInTime = (schedule: any) => {
  const now = new Date();
  const clockInTime = new Date(schedule.clock_in_time);
  // Allow clock in up to 10 minutes before the scheduled time.
  const allowedEarlyTime = new Date(clockInTime.getTime() - 10 * 60 * 1000);
  if (now < allowedEarlyTime) {
    throw new Error("Clock-in time is not valid.");
  }
};


// Helper function to validate schedule details on creation
const validateScheduleDetails = (scheduleDetails: any) => {
  const { attendanceScheduleName, country, branch } = scheduleDetails;
  if (!attendanceScheduleName || !Array.isArray(country) || !Array.isArray(branch)) {
    throw new Error("Invalid schedule details");
  }
};

/**
 * Create a new schedule.
 * Note: The schedule id is now automatically generated by the database.
 */
const createSchedule = async (req: Request, res: Response) => {
  try {
    let {
      attendanceScheduleName,
      country,
      branch,
      scheduleCategory,
      scheduleSpan,
      clockInTime,
      clockOutTime,
      lateTime,
      setBreak,
      startBreakTime,
      endBreakTime,
      locationType,
      knownLocations,
      recurring,
      recurringDays,
      recurringDuration,
      nonRecurringDates,
      overtimeStatus,
      virtualMeeting,
      monthlyClockingOccurrences,
      monthlyMinClockingOccurrences,
      unlimitedShadow // when true the schedule never “expires”
    } = req.body;

    // Validate schedule details
    validateScheduleDetails(req.body);

    // Provide default for recurringDuration if null
    recurringDuration = recurringDuration ?? "";

    const result = await dataSource.query(
      `
      INSERT INTO attendance_schedules (
        attendance_schedule_name,
        country, 
        branch, 
        schedule_category,
        schedule_span, 
        clock_in_time, 
        clock_out_time, 
        late_time, 
        set_break, 
        start_break_time, 
        end_break_time, 
        location_type, 
        known_locations, 
        recurring, 
        recurring_days, 
        recurring_duration, 
        non_recurring_dates, 
        overtime_status, 
        virtual_meeting, 
        monthly_clocking_occurrences, 
        monthly_min_clocking_occurrences,
        unlimited_shadow
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22)
      RETURNING *;
      `,
      [
        attendanceScheduleName,
        JSON.stringify(country),
        JSON.stringify(branch),
        scheduleCategory,
        scheduleSpan,
        clockInTime,
        clockOutTime,
        lateTime,
        setBreak,
        startBreakTime,
        endBreakTime,
        locationType,
        JSON.stringify(knownLocations),
        recurring,
        JSON.stringify(recurringDays),
        recurringDuration,
        JSON.stringify(nonRecurringDates),
        overtimeStatus,
        virtualMeeting,
        monthlyClockingOccurrences,
        monthlyMinClockingOccurrences,
        unlimitedShadow
      ]
    );

    res.status(200).json({
      success: true,
      message: "Schedule created successfully.",
      data: result[0]
    });
  } catch (error: any) {
    res.status(500).json({
      success: false,
      error: error.message,
    });
  }
};

// Clock in for an individual user
const clockInIndividual = async (req: Request, res: Response) => {
  try {
    const { scheduleId, userId, location, deviceInfo } = req.body;

    if (!isValidLocation(location)) {
      res.status(400).json({
        success: false,
        error: "Invalid location: Latitude or longitude is not a valid number.",
      });
      return;
    }

    const schedule = await getScheduleById(scheduleId);
    validateClockInTime(schedule);

    // Insert the attendance record into the new table.
    const result = await dataSource.query(
      `
      INSERT INTO attendance_attendance (schedule_id, user_id, clock_in_time, coordinates, device_info)
      VALUES ($1, $2, CURRENT_TIMESTAMP, $3, $4)
      ON CONFLICT (schedule_id, user_id) DO UPDATE
      SET clock_in_time = EXCLUDED.clock_in_time
      RETURNING *;
      `,
      [scheduleId, userId, JSON.stringify(location), JSON.stringify(deviceInfo)]
    );

    res.status(200).json({
      success: true,
      message: "User clocked in successfully.",
      data: result[0],
    });
  } catch (error: any) {
    res.status(400).json({
      success: false,
      error: error.message,
    });
  }
};

// Clock in for multiple users (Bulk)
const clockInBulk = async (req: Request, res: Response) => {
  try {
    const { scheduleId, users } = req.body;

    for (const user of users) {
      if (!isValidLocation(user.location)) {
        res.status(400).json({
          success: false,
          error: `Invalid location value for user ${user.userId}.`,
        });
        return;
      }
    }

    const schedule = await getScheduleById(scheduleId);
    validateClockInTime(schedule);

    // Build values for the bulk insert query.
    const values = users
      .map(
        (user: { userId: number; location: { latitude: number; longitude: number }; deviceInfo: any }) =>
          `('${scheduleId}', ${user.userId}, CURRENT_TIMESTAMP, '${JSON.stringify(user.location)}', '${JSON.stringify(user.deviceInfo)}')`
      )
      .join(",");

    const query = `
      INSERT INTO attendance_attendance (schedule_id, user_id, clock_in_time, coordinates, device_info)
      VALUES ${values}
      ON CONFLICT (schedule_id, user_id) DO UPDATE
      SET clock_in_time = EXCLUDED.clock_in_time;
    `;

    await dataSource.query(query);

    res.status(200).json({
      success: true,
      message: "Users clocked in successfully.",
    });
  } catch (error: any) {
    res.status(400).json({
      success: false,
      error: error.message,
    });
  }
};

// Clock out for an individual user
const clockOutIndividual = async (req: Request, res: Response) => {
  try {
    const { userId, scheduleId, location, deviceInfo } = req.body;

    if (
      !location ||
      typeof location.latitude === "undefined" ||
      typeof location.longitude === "undefined"
    ) {
      res.status(400).json({
        success: false,
        error: "Invalid location: Latitude or longitude is missing.",
      });
      return;
    }

    if (!isValidLocation(location)) {
      res.status(400).json({
        success: false,
        error: "Invalid location: Latitude or longitude is not a valid number.",
      });
      return;
    }

    const attendanceResult = await dataSource.query(
      `
      SELECT * FROM attendance_attendance
      WHERE user_id = $1 AND schedule_id = $2 AND clock_out_time IS NULL
      `,
      [userId, scheduleId]
    );

    if (attendanceResult.length === 0) {
      res.status(404).json({
        success: false,
        message: "Active clock in record not found for clocking out.",
      });
      return;
    }

    const attendanceRecord = attendanceResult[0];
    const clockInTime = new Date(attendanceRecord.clock_in_time);
    const schedule = await getScheduleById(scheduleId);

    if (!schedule.unlimited_shadow) {
      const allowedDeadline = new Date(
        clockInTime.getTime() + (parseInt(schedule.schedule_span, 10) || 1) * 24 * 60 * 60 * 1000
      );
      const now = new Date();
      if (now > allowedDeadline) {
        res.status(400).json({
          success: false,
          error: "Clock out period has expired.",
        });
        return;
      }
    }

    const result = await dataSource.query(
      `
      UPDATE attendance_attendance
      SET clock_out_time = CURRENT_TIMESTAMP, coordinates = $3, device_info = $4
      WHERE user_id = $1 AND schedule_id = $2 AND clock_out_time IS NULL
      RETURNING *;
      `,
      [userId, scheduleId, JSON.stringify(location), JSON.stringify(deviceInfo)]
    );

    res.status(200).json({
      success: true,
      message: "User clocked out successfully.",
      data: result[0],
    });
  } catch (error: any) {
    res.status(500).json({
      success: false,
      error: error.message,
    });
  }
};

/**
 * New Endpoint: Bulk Create Schedules
 * This endpoint processes an uploaded CSV file (from the "bulkScheduleFile" form field)
 * and creates multiple schedule records in one request.
 *
 * Expected additional form fields (besides the file):
 * - country (array or comma-separated string)
 * - branch (array or comma-separated string)
 * - scheduleStatus ("limited" or "unlimited") – translated into the unlimited_shadow field
 */
const bulkCreateSchedules = async (req: MulterRequest, res: Response) => {
  try {
    const { country, branch, scheduleStatus } = req.body;
    // Determine unlimitedShadow based on scheduleStatus from the UI
    const unlimitedShadow = scheduleStatus === "unlimited";

    if (!req.file) {
      return res.status(400).json({ success: false, error: "No file uploaded" });
    }

    // Convert the file buffer to string.
    const csvData = req.file.buffer.toString();

    // Use fast-csv to parse CSV data asynchronously.
    const records: any[] = [];
    await new Promise<void>((resolve, reject) => {
      parseString(csvData, { headers: true, ignoreEmpty: true })
        .on("error", (error: Error) => reject(error))
        .on("data", (row: any) => records.push(row))
        .on("end", () => resolve());
    });

    const createdSchedules = [];

    for (const row of records) {
      // Skip rows missing required fields
      if (!row.attendanceScheduleName || !row.scheduleSpan || !row.clockInTime || !row.clockOutTime) {
        continue;
      }

      // Provide default for recurringDuration if null
      row.recurringDuration = row.recurringDuration ?? "";

      const result = await dataSource.query(
        `
        INSERT INTO attendance_schedules (
          attendance_schedule_name,
          country, 
          branch, 
          schedule_category,
          schedule_span, 
          clock_in_time, 
          clock_out_time, 
          late_time, 
          set_break, 
          start_break_time, 
          end_break_time, 
          location_type, 
          known_locations, 
          recurring, 
          recurring_days, 
          recurring_duration, 
          non_recurring_dates, 
          overtime_status, 
          virtual_meeting, 
          monthly_clocking_occurrences, 
          monthly_min_clocking_occurrences,
          unlimited_shadow
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22)
        RETURNING *;
        `,
        [
          row.attendanceScheduleName,
          Array.isArray(country)
            ? JSON.stringify(country)
            : JSON.stringify(country.split(",").map((s: string) => s.trim())),
          Array.isArray(branch)
            ? JSON.stringify(branch)
            : JSON.stringify(branch.split(",").map((s: string) => s.trim())),
          row.scheduleCategory || null,
          row.scheduleSpan,
          row.clockInTime,
          row.clockOutTime,
          row.lateTime,
          row.setBreak,
          row.startBreakTime,
          row.endBreakTime,
          row.locationType,
          row.knownLocations
            ? JSON.stringify(row.knownLocations.split(",").map((s: string) => s.trim()))
            : JSON.stringify([]),
          row.recurring,
          row.recurringDays
            ? JSON.stringify(row.recurringDays.split(",").map((s: string) => s.trim()))
            : JSON.stringify([]),
          row.recurringDuration,
          JSON.stringify(row.nonRecurringDates ? row.nonRecurringDates.split(",").map((s: string) => s.trim()) : []),
          row.overtimeStatus,
          row.virtualMeeting,
          row.monthlyClockingOccurrences,
          row.monthlyMinClockingOccurrences,
          unlimitedShadow
        ]
      );
      createdSchedules.push(result[0]);
    }

    res.status(200).json({
      success: true,
      message: "Bulk schedules created successfully.",
      data: createdSchedules
    });
  } catch (error: any) {
    res.status(500).json({
      success: false,
      error: error.message,
    });
  }
};

export {
  createSchedule,
  clockInIndividual,
  clockInBulk,
  clockOutIndividual,
  bulkCreateSchedules,
};
